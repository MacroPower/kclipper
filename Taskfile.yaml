version: "3"

vars:
  GO_FILES_CMD: >-
    go list -f {{"{{.Dir}}"}} ./... | xargs -I {} find {} -name "*.go"
  NIX_VENDOR_DIR: "{{.ROOT_DIR}}/.nixpkgs/vendor"
  SDK_PATH: "{{.NIX_VENDOR_DIR}}/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk"
  NIX_SDK_PATH: "{{.DEVBOX_PACKAGES_DIR}}/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk"
  FRAMEWORK_PATH: "{{.SDK_PATH}}/System/Library/Frameworks"
  INCLUDE_PATH: "{{.SDK_PATH}}/usr/include"
  LIB_PATH: "{{.SDK_PATH}}/usr/lib"
  C_ENV: "{{OS | upper}}_{{ARCH | upper}}"
  PRETTIER_TARGETS: "*.{yaml,md,json} **/*.{yaml,md,json}"
  ZIG_WRAPPER_DIR: "{{.ROOT_DIR}}/hack"

env:
  HOSTNAME:
    sh: hostname
  KCL_LSP_VERSION: v0.11.2
  CC_LINUX_AMD64: "{{.ZIG_WRAPPER_DIR}}/zig-gold-wrapper.sh -target x86_64-linux-gnu"
  CC_LINUX_ARM64: "{{.ZIG_WRAPPER_DIR}}/zig-gold-wrapper.sh -target aarch64-linux-gnu"
  CC_DARWIN_AMD64: "{{.ZIG_WRAPPER_DIR}}/zig-macos-wrapper.sh -target x86_64-macos-none -F{{.FRAMEWORK_PATH}} -I{{.INCLUDE_PATH}} -L{{.LIB_PATH}} -Wno-availability -Wno-nullability-completeness"
  CC_DARWIN_ARM64: "{{.ZIG_WRAPPER_DIR}}/zig-macos-wrapper.sh -target aarch64-macos-none -F{{.FRAMEWORK_PATH}} -I{{.INCLUDE_PATH}} -L{{.LIB_PATH}} -Wno-availability -Wno-nullability-completeness"
  CXX_LINUX_AMD64: "{{.ZIG_WRAPPER_DIR}}/zig-gold-wrapper.sh -target x86_64-linux-gnu"
  CXX_LINUX_ARM64: "{{.ZIG_WRAPPER_DIR}}/zig-gold-wrapper.sh -target aarch64-linux-gnu"
  CXX_DARWIN_AMD64: "{{.ZIG_WRAPPER_DIR}}/zig-macos-wrapper.sh -target x86_64-macos-none -F{{.FRAMEWORK_PATH}} -I{{.INCLUDE_PATH}} -L{{.LIB_PATH}} -Wno-availability -Wno-nullability-completeness"
  CXX_DARWIN_ARM64: "{{.ZIG_WRAPPER_DIR}}/zig-macos-wrapper.sh -target aarch64-macos-none -F{{.FRAMEWORK_PATH}} -I{{.INCLUDE_PATH}} -L{{.LIB_PATH}} -Wno-availability -Wno-nullability-completeness"
  BUILD_TAGS: netgo

tasks:
  default:
    cmds:
      - task: format
      - task: lint
      - task: test
      - task: build

  # ---------------------------------------------------------------------------
  # Dagger-based CI tasks
  # ---------------------------------------------------------------------------

  format:
    desc: Formats code via Dagger
    cmds:
      - dagger generate --auto-apply

  lint:
    desc: Runs all lint checks via Dagger
    cmds:
      - dagger check lint lint-prettier lint-actions lint-releaser

  lint:go:
    desc: Lints Go code via Dagger
    cmds:
      - dagger check lint

  lint:prettier:
    desc: Checks formatting of YAML, JSON, and Markdown via Dagger
    cmds:
      - dagger check lint-prettier

  lint:actions:
    desc: Lints GitHub Actions workflows via Dagger
    cmds:
      - dagger check lint-actions

  lint:releaser:
    desc: Validates GoReleaser configuration via Dagger
    cmds:
      - dagger check lint-releaser

  lint:commit-msg:
    desc: Validates commit message format via Dagger
    requires:
      vars: [MSG_FILE]
    cmds:
      - dagger call lint-commit-msg --msg-file={{.MSG_FILE}}

  test:
    desc: Runs Go tests via Dagger
    cmds:
      - dagger check test

  test:integration:
    desc: Runs CI module integration tests via Dagger
    cmds:
      - dagger check -m ci/tests

  build:
    desc: Builds all binaries via Dagger
    cmds:
      - dagger call build export --path=./dist

  cover:
    desc: Runs Go tests with coverage via Dagger
    cmds:
      - dagger call test-coverage export --path=coverage.txt

  check:
    desc: Runs all checks via Dagger
    cmds:
      - dagger check

  release:
    desc: Runs full release via Dagger
    requires:
      vars: [GITHUB_TOKEN, TAG, REGISTRY_USERNAME, REGISTRY_PASSWORD]
    cmds:
      - >-
        dagger call release
        --github-token=env://GITHUB_TOKEN
        --registry-username={{.REGISTRY_USERNAME}}
        --registry-password=env://REGISTRY_PASSWORD
        --tag={{.TAG}}
        export --path=./dist

  # ---------------------------------------------------------------------------
  # Local-only tasks (no Dagger)
  # ---------------------------------------------------------------------------

  pre-commit:
    desc: Runs all pre-commit targets
    deps: [lint, test]

  install:
    desc: Builds and installs binaries
    env:
      HELM_VERSION:
        sh: helm version --template="{{ "{{.Version}}" }}"
    cmds:
      - goreleaser build --snapshot --clean --single-target
      - sudo cp ./dist/*/kcl /usr/local/bin

  go-bench:
    desc: Run Go benchmarks
    summary: |
      Run Go benchmarks

      Args:
        PKG: Go package to test (default: ./...)
        FLAGS: Additional flags to pass to `go test` (default: "")

      Examples:
        task go-bench PKG=./pkg/helm FLAGS="-cpuprofile profile.out -run=^\$"
    vars:
      PKG: '{{.PKG | default "./..."}}'
      FLAGS: '{{.FLAGS | default ""}}'
    cmds:
      - go test -bench=. -benchmem -tags={{.BUILD_TAGS}} {{.FLAGS}} {{.PKG}}

  go-gen:
    desc: Generates Go code
    cmds:
      - go generate ./...

  go-deadcode:
    desc: Finds dead code in Go
    summary: |
      Finds dead code in Go.

      Args:
        PKG: Go package(s) to evaluate (default: ./...)
        FLAGS: Additional flags to pass to `deadcode` (default: "")

      Examples:
        task go-deadcode FLAGS="-test -generated"
    vars:
      PKG: '{{.PKG | default "./..."}}'
      FLAGS: '{{.FLAGS | default ""}}'
    cmds:
      - go install golang.org/x/tools/cmd/deadcode@latest
      - deadcode {{.FLAGS}} {{.PKG}}

  go-bench-init:
    desc: Run Go benchmarks with init tracing
    cmds:
      - |
        echo "a=1" | GODEBUG=inittrace=1 kcl run - 2>&1 | awk '
        BEGIN {
            printf "%-100s %-15s %-15s %-10s %-10s\n", "Module", "Init Time (ms)", "Clock Time (ms)", "Bytes", "Allocs";
            printf "%-100s %-15s %-15s %-10s %-10s\n", "------", "--------------", "---------------", "-----", "------";
        }
        $1 == "init" {
            # Extract the relevant fields and format them into a table
            module = $2;
            init_time = substr($3, 2);  # Remove the "@" prefix
            clock_time = $5;
            bytes = $8;
            allocs = $10;
            printf "%-100s %-15s %-15s %-10s %-10s\n", module, init_time, clock_time, bytes, allocs;
        }' | tail -n +3 | sort -k3,3n

  pull-upstream:
    desc: Pulls upstream KCL CLI
    sources:
      - .tmp/kcl
    cmds:
      - |
        mkdir -p ./.tmp/bin
        curl -Lq https://github.com/kcl-lang/cli/releases/download/v0.11.0/kcl-v0.11.0-{{OS}}-{{ARCH}}.tar.gz | \
          tar -xzO kcl > ./.tmp/bin/kcl
        chmod +x ./.tmp/bin/kcl

  bench-diff:
    desc: Compares benchmark results
    deps:
      - task: build
      - task: pull-upstream
    vars:
      KCLX_BIN: ../../dist/kclipper_{{OS}}_{{ARCH}}*/kcl
      KCL_CODE: no-charts.k
      KCL_HELM: 10-charts.k
      KCL_HELM_VALUES: 10-charts-with-values.k
    cmds:
      - cp ./.tmp/bin/kcl ./docs/benchmarks/kcl
      - defer: rm ./docs/benchmarks/kcl
      - |-
        cd docs/benchmarks
        hyperfine --warmup=50 --min-runs=1000 \
          --export-markdown ../README.md \
          --command-name "kcl(ipper) -V {{.KCL_CODE}}" \
          --command-name "kcl(ipper) -V {{.KCL_HELM}}" \
          --command-name "kcl(ipper) -V {{.KCL_HELM_VALUES}}" \
          --reference "kcl -V {{.KCL_CODE}}" \
          "{{.KCLX_BIN}} -V {{.KCL_CODE}}" \
          "{{.KCLX_BIN}} -V {{.KCL_HELM}}" \
          "{{.KCLX_BIN}} -V {{.KCL_HELM_VALUES}}"

  bench-diff-docker:
    desc: Compares benchmark results
    vars:
      DOCKER_MOUNTS: "-v ./.tmp:/tmp -v ./docs/benchmarks:/opt/benchmarks"
      KCL_CODE: benchmarks/no-charts.k
      KCL_HELM: benchmarks/10-charts.k
    cmds:
      - >-
        docker run --name=kcl -d --entrypoint=/usr/bin/bash {{.DOCKER_MOUNTS}}
        kcllang/kcl-arm64:latest -c "sleep 300"
      - defer: "docker rm kcl -f"
      - docker exec kcl kcl version
      - >-
        docker run --name=kclipper -d --entrypoint=/usr/bin/bash {{.DOCKER_MOUNTS}}
        ghcr.io/macropower/kclipper:v0.2.0-arm64 -c "sleep 300"
      - defer: "docker rm kclipper -f"
      - docker exec kclipper kcl version
      - >-
        hyperfine --warmup=1
        --command-name "docker ../{{.KCL_CODE}}"
        --command-name "docker ../{{.KCL_HELM}}"
        --reference "docker exec kcl kcl run /opt/{{.KCL_CODE}}"
        "docker exec kclipper kcl run /opt/{{.KCL_CODE}}"
        "docker exec kclipper kcl run /opt/{{.KCL_HELM}}"

  kcl-doc:
    desc: Generates KCL documentation
    summary: |
      Generates KCL documentation from a KCL module.

      Args:
        MODULE: KCL module to document

      Examples:
        task kcl-doc MODULE=helm
    requires:
      vars: [MODULE]
    cmds:
      - kcl doc generate --file-path=./modules/{{.MODULE}} --target=./modules/{{.MODULE}}
      - cat ./modules/{{.MODULE}}/docs/README.md >> ./modules/{{.MODULE}}/README.md
      - rm -rf ./modules/{{.MODULE}}/docs
      - task: format

  run-chartmuseum:
    cmd: |-
      docker run --rm -it \
        -p 8080:8080 \
        -e DEBUG=1 \
        -e STORAGE=local \
        -e STORAGE_LOCAL_ROOTDIR=/charts \
        -e BASIC_AUTH_USER=user \
        -e BASIC_AUTH_PASS=hunter2 \
        -v $(pwd)/charts:/charts \
        ghcr.io/helm/chartmuseum:v0.16.2
    # helm package .
    # curl -u user:hunter2 --data-binary "@simple-chart-0.1.0.tgz" http://localhost:8080/api/charts

  install-hooks:
    desc: Install git hooks
    cmds:
      - lefthook install

  # Since these are impossible to compile properly on linux...
  update-macos-sdk:
    cmds:
      - rm -rf {{.SDK_PATH}}
      - mkdir -p {{.SDK_PATH}}/System/Library/Frameworks/CoreFoundation.framework
      - mkdir -p {{.SDK_PATH}}/System/Library/Frameworks/Security.framework
      - mkdir -p {{.INCLUDE_PATH}}/mach
      - mkdir -p {{.LIB_PATH}}
      - cp -r {{.NIX_SDK_PATH}}/System/Library/Frameworks/CoreFoundation.framework/* {{.SDK_PATH}}/System/Library/Frameworks/CoreFoundation.framework
      - cp -r {{.NIX_SDK_PATH}}/System/Library/Frameworks/Security.framework/* {{.SDK_PATH}}/System/Library/Frameworks/Security.framework
      - cp -r {{.NIX_SDK_PATH}}/usr/lib/libobjc* {{.LIB_PATH}}/
      - cp -r {{.NIX_SDK_PATH}}/usr/include/mach/* {{.INCLUDE_PATH}}/mach

  dev:
    desc: Opens a development shell via Dagger (changes persist on exit)
    interactive: true
    requires:
      vars: [BRANCH]
    vars:
      DIR: '{{.BRANCH | replace "/" "-"}}'
    cmds:
      - >-
        dagger call dev
        --branch={{.BRANCH}}
        --git-config ~/.config/git
        --tz="$TZ"
        --colorterm="$COLORTERM"
        --term-program="$TERM_PROGRAM"
        --term-program-version="$TERM_PROGRAM_VERSION"
        export --path=/tmp/dagger-dev-{{.DIR}}
      # Import container commits into host repo
      - git fetch /tmp/dagger-dev-{{.DIR}} {{.BRANCH}}:{{.BRANCH}} || true
      # Ensure host worktree exists
      - |
        if [ ! -d ".worktrees/{{.DIR}}" ]; then
          if git show-ref --verify --quiet "refs/heads/{{.BRANCH}}"; then
            git worktree add ".worktrees/{{.DIR}}" "{{.BRANCH}}"
          else
            git worktree add -b "{{.BRANCH}}" ".worktrees/{{.DIR}}"
          fi
        fi
      # Sync source files (tar preserves permissions, excludes .git)
      - tar -C /tmp/dagger-dev-{{.DIR}} --exclude=.git -cf - . | tar -C .worktrees/{{.DIR}} -xf -
      # Clean up temp
      - rm -rf /tmp/dagger-dev-{{.DIR}}

  claude:
    desc: Launches Claude Code via Dagger (changes persist on exit)
    interactive: true
    requires:
      vars: [BRANCH]
    vars:
      DIR: '{{.BRANCH | replace "/" "-"}}'
    cmds:
      - >-
        dagger call dev
        --branch={{.BRANCH}}
        --claude-config ~/.claude
        --claude-json ~/.claude.json
        --git-config ~/.config/git
        --ccstatusline-config ~/.config/ccstatusline
        --tz="$TZ"
        --colorterm="$COLORTERM"
        --term-program="$TERM_PROGRAM"
        --term-program-version="$TERM_PROGRAM_VERSION"
        --cmd claude,--dangerously-skip-permissions
        export --path=/tmp/dagger-dev-{{.DIR}}
      - git fetch /tmp/dagger-dev-{{.DIR}} {{.BRANCH}}:{{.BRANCH}} || true
      - |
        if [ ! -d ".worktrees/{{.DIR}}" ]; then
          if git show-ref --verify --quiet "refs/heads/{{.BRANCH}}"; then
            git worktree add ".worktrees/{{.DIR}}" "{{.BRANCH}}"
          else
            git worktree add -b "{{.BRANCH}}" ".worktrees/{{.DIR}}"
          fi
        fi
      - tar -C /tmp/dagger-dev-{{.DIR}} --exclude=.git -cf - . | tar -C .worktrees/{{.DIR}} -xf -
      - rm -rf /tmp/dagger-dev-{{.DIR}}

  git:worktree:add:
    desc: Adds a git worktree for the given branch
    summary: |
      Adds a git worktree under .worktrees/ for the given branch.
      Creates the branch if it doesn't already exist.

      Args:
        BRANCH: Branch name (required, e.g. feat/foo)
    requires:
      vars: [BRANCH]
    vars:
      DIR: '{{.BRANCH | replace "/" "-"}}'
    cmds:
      - |
        if git show-ref --verify --quiet "refs/heads/{{.BRANCH}}"; then
          git worktree add ".worktrees/{{.DIR}}" "{{.BRANCH}}"
        elif git show-ref --verify --quiet "refs/remotes/origin/{{.BRANCH}}"; then
          git worktree add ".worktrees/{{.DIR}}" "{{.BRANCH}}"
        else
          git worktree add -b "{{.BRANCH}}" ".worktrees/{{.DIR}}"
        fi

  git:worktree:ls:
    desc: Lists all git worktrees
    cmds:
      - git worktree list

  git:worktree:rm:
    desc: Removes a git worktree and deletes the branch
    summary: |
      Removes the worktree under .worktrees/ for the given branch
      and deletes the branch.

      Args:
        BRANCH: Branch name (required, e.g. feat/foo)
    requires:
      vars: [BRANCH]
    vars:
      DIR: '{{.BRANCH | replace "/" "-"}}'
    cmds:
      - git worktree remove ".worktrees/{{.DIR}}"
      - git branch -D "{{.BRANCH}}"
